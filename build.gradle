plugins {
	id "java"
	id "idea"

	id "architectury-plugin" version "3.4-SNAPSHOT"
    id "dev.architectury.loom" version "1.7-SNAPSHOT" apply false

	id "com.github.johnrengelman.shadow" version "8.1.1" apply false
	id "systems.manifold.manifold-gradle-plugin" version "0.0.2-alpha"
	id "me.shedaniel.unified-publishing" version "0.1.+" apply false
	id "me.modmuss50.mod-publish-plugin" version "0.6.3"
}

/**
 * Borrowed from Distant Horizons
 */
def writeBuildGradlePredefine(List<String> AvailableVersion, int versionIndex) {
	StringBuilder sb = new StringBuilder()

	sb.append("# DON'T TOUCH THIS FILE, This is handled by the build script\n")

	for (int i = 0; i < AvailableVersion.size(); i++) {
		String versionString = AvailableVersion[i].replace(".", "_")
		sb.append("MC_" + versionString + "=" + i.toString() + "\n")
		ext.set("MC_" + versionString, i.toString())

		if (versionIndex == i) {
			sb.append("MC_VER=" + i.toString() + "\n")
			ext.set("MC_VER", i.toString())
		}
	}

	new File(projectDir, "build.properties").text = sb.toString()
}

project.gradle.ext.getProperties().each { prop ->
	ext.set(prop.key, prop.value)
}

writeBuildGradlePredefine(availableVersions, versionIndex)

architectury {
	minecraft = minecraftVersion
}

allprojects {
	base.archivesName = projectArchivesName
	version = "${modVersion}-${minecraftVersion}"
	group = projectGroup
}

subprojects {
	boolean isMinecraftSubProject = findProject("common") != project
	boolean isFabric = findProject("fabric") == project
	boolean isForge = findProject("forge") == project
	boolean isNeoForge = findProject("neoforge") == project

	apply plugin: "java"
	apply plugin: "idea"
	apply plugin: "architectury-plugin"
	apply plugin: "dev.architectury.loom"

	apply plugin: "maven-publish"
	apply plugin: "com.github.johnrengelman.shadow"
	if (isMinecraftSubProject)
		apply plugin: "me.shedaniel.unified-publishing"

	base.archivesName.set("${base.archivesName}-${project.name}")

	loom {
		silentMojangMappingsLicense()
	}

	configurations {
		common
		shadowCommon
		compileClasspath.extendsFrom(common)
		runtimeClasspath.extendsFrom(common)
	}

	repositories {
		mavenCentral()
		mavenLocal()

		maven {
			name = "Parchment"
			url = "https://maven.parchmentmc.org"
		}
		maven {
			name = "Fabric"
			url = "https://maven.fabricmc.net/"
		}
		maven {
			name = "Forge"
			url = "https://maven.minecraftforge.net/"
		}
		maven {
			name = "NeoForge"
			url = "https://maven.neoforged.net/releases/"
		}
	}

	dependencies {
		minecraft("com.mojang:minecraft:${minecraftVersion}")
		mappings(loom.layered {
			officialMojangMappings()
			parchment("org.parchmentmc.data:parchment-${parchmentMinecraftVersion}:${parchmentVersion}@zip")
		})

		compileOnly("org.jetbrains:annotations:24.1.0")
		annotationProcessor("systems.manifold:manifold-preprocessor:${manifoldVersion}")
	}

	processResources {
		inputs.property("version", version)

		filesMatching(["META-INF/mods.toml", "META-INF/neoforge.mods.toml", "pack.mcmeta", "fabric.mod.json"]) {
			expand([
					minecraftVersion          : minecraftVersion,

					modId                     : modId,
					modVersion                : modVersion,
					modName                   : modName,
					modDescription            : modDescription,
					modAuthor                 : modAuthor,

					fabricCompatibleVersions  : fabricCompatibleVersions,
					forgeCompatibleVersions   : forgeCompatibleVersions,
					neoForgeCompatibleVersions: neoForgeCompatibleVersions
			])
		}
	}

	if (isMinecraftSubProject) {
		shadowJar {
			configurations = [project.configurations.shadowCommon]
			archiveClassifier.set("dev-shadow")
		}

		remapJar {
			inputFile.set(shadowJar.archiveFile)
			dependsOn(shadowJar)
		}
	}

	tasks.withType(JavaCompile).configureEach {
		options.encoding = "UTF-8"
		options.release = 21
		options.compilerArgs += ["-Xplugin:Manifold"]
	}

	jar {
		manifest {
			attributes([
					"Specification-Title"   : modName,
					"Specification-Vendor"  : modAuthor,
					"Specification-Version" : modVersion,
					"Implementation-Title"  : name,
					"Implementation-Vendor" : modAuthor,
					"Implementation-Version": archiveVersion
			])
		}
	}

	java {
		withSourcesJar()
	}
}

var curseForgeAPIKey = providers.environmentVariable("CURSEFORGE_API_KEY")
var modrinthAPIKey = providers.environmentVariable("MODRINTH_API_KEY")
var githubAPIKey = providers.environmentVariable("GITHUB_API_KEY")

publishMods {
	dryRun = Boolean.parseBoolean(publishingDryRun)

	version = modVersion
	changelog = rootProject.file("CHANGELOG.md").text

	// Set the release type
	switch (publishingReleaseType as int) {
		case 2:
			type = ALPHA
			break
		case 1:
			type = BETA
			break
		default:
			type = STABLE
	}

	var isRangedVersion = hasProperty("publishingLatestMinecraftVersion")
	var minecraftVersionStr = isRangedVersion ?
			"${rootProject.publishingMinecraftVersion}-${rootProject.publishingLatestMinecraftVersion}" :
			rootProject.publishingMinecraftVersion

	// Creates publish options for each supported mod loader
	for (loaderName in ((String) supportedModLoaders).strip().split(",")) {
		var loaderDisplayName
		switch (loaderName) {
			case "fabric":
				loaderDisplayName = "Fabric"
				break
			case "forge":
				loaderDisplayName = "Forge"
				break
			case "neoforge":
				loaderDisplayName = "NeoForge"
				break
			default:
				loaderDisplayName = loaderName
		}

		curseforge("curseforge_" + loaderName) {
			accessToken = curseForgeAPIKey
			displayName = "[${loaderDisplayName} ${minecraftVersionStr}] v${modVersion}"

			projectId = publishingCurseForgeProjectId

			modLoaders.add(loaderName)
			file = project(":" + loaderName).remapJar.archiveFile

			if (isRangedVersion)
				minecraftVersionRange {
					start = publishingMinecraftVersion
					end = publishingLatestMinecraftVersion
				}
			else
				minecraftVersions.add(publishingMinecraftVersion)

			javaVersions.add(JavaVersion.VERSION_21)

			clientRequired = true
			serverRequired = true

			if (loaderName == "fabric")
				requires("fabric-api")
		}

		modrinth("modrinth_" + loaderName) {
			accessToken = modrinthAPIKey
			displayName = "[${loaderDisplayName} ${minecraftVersionStr}] v${modVersion}"

			projectId = publishingModrinthProjectId

			modLoaders.add(loaderName)
			file = project(":" + loaderName).remapJar.archiveFile

			if (isRangedVersion)
				minecraftVersionRange {
					start = publishingMinecraftVersion
					end = publishingLatestMinecraftVersion
				}
			else
				minecraftVersions.add(publishingMinecraftVersion)

			if (loaderName == "fabric")
				requires("fabric-api")
		}
	}

	var githubRepository = publishingGitHubRepo
	var releaseType
	switch (type) {
		case ALPHA:
			releaseType = "alpha"
			break
		case BETA:
			releaseType = "beta"
			break
		default:
			releaseType = "stable"
	}
	var githubTagName = "${releaseType}/${modVersion}-${minecraftVersionStr}"
	github {
		accessToken = githubAPIKey
		repository = githubRepository
		tagName = githubTagName
		commitish = "main"

		modLoaders.addAll(supportedModLoaders.trim().split(","))
		file = project(":common").remapJar.archiveFile

		for (loaderName in ((String) supportedModLoaders).strip().split(",")) {
			additionalFiles.from(project(":" + loaderName).remapJar.archiveFile)
		}
	}
}